Άσκηση 2
Παναγιώτα Γύφτου , Α.Μ. 1115201900318

1.Οι εντολές μεταγλώττισης του προγράμματος βρίσκονται στο αρχείο Makefile, δηλαδή η μεταγλώττιση γίνεται με το make.
2. Και τρέχω το πρόγραμμα: ./main 3 4 20 3
   (δηλ. K=3 M=4 N=20 L=3)

3.
-Επιλογές κλάσεων:
Έχω δύο κλάσεις.Την κλάση Bank και την κλάση Cash_desk.Το πρόβλημα κινείται γύρω από αυτές τις δύο κλάσεις.Συνολικά έχω 6 αντικείμενα, τα 5 εκ΄των οποίων (τα ταμεία) έχουν την ίδια συμπεριφορά και ανήκουν στο σύνολο της κλάσης Cash_desk.Το άλλο αντικείμενο είναι η τράπεζα.Τους ανθρώπους τους αντιμετωπίζω ως μεταβλητές πχ waiting_people, last_customers κλπ. και όχι ως αντικείμενο ,γιατί στην συγκεκριμένη άσκηση δεν έχουν κάποια ιδιότητα που θα συμβάλει στην λειτουργία του προγράμματός.


-Επιλογές ορατότητας μελών κλάσεων:
Στον private χώρο της κλάσης Bank έχω βάλει δεδομένα όπου χαρακτηρίζουν το αντικείμενο, μερικά από τα οποία είναι ο αριθμός των ταμείων (int cashiers), ο αριθμός των τρέχοντων ανοικτών ταμείων (int counter_open), ποιος αριθμός πελάτης είναι προς εξυπηρέτηση (int curr_serving) κλπ.Αντίστοιχα το ίδιο συμβαίνει και στην κλάση Cash_desκ, έχω βάλει δεδομένα που χαρακτηρίζουν το σύνολο των αντικειμένων της.Η σύνδεση των αντικειμένων της κλάσης Cash_desk και του αντικειμένου της κλάσης Bank φαίνεται στον private χώρο της κλάσης Bank (class Cash_Desk ** cash_desk_array), με τον δείκτη σε πίνακα.Η κλάση Bank κατα την δημιουργία της διεγείρει και την δημιουργία των 5 ταμείων.Η επαφή γίνεται μέσω των δημόσιων συναρτήσεων.Κάθε ταμείο για την Bank έχει ένα μοναδικό αναγνωριστικό, ώστε να καλεί το συγκεκριμένο αντικείμενο που θέλει κάθε φορά, αλλά και στέλνοντας μέσω συναρτήσεων της κλάσης Cash_desκ και με συγκεκριμένα ορίσματα τι δουλειά θέλει να κάνει το ταμείο για την Bank.Οι public συναρτήσεις της κλάσης Bank εκτός από τον Constructor και τον Destructor είναι κυρίως για την επικοινωνία με τον χρήστη (ώστε να μπορεί το αντικείμενο της κλάσης να διεκπεραιώσει τις δουλειές που του ανατίθενται) αλλά και συναρτήσεις όπου εκτελεί διάφορες λειτουργίες.


-Περιγραφή Προγράμματος:

**Δημιουργία Τράπεζας**
Αρχικά δημιουργώ την τράπεζα μέσω της συνάρτησης κατασκευής της κλάσης Bank.Η συνάρτηση αυτή διεγείρει την δημιουργία των 5 αντικειμένων που επιδεικνύουν την ίδια ακριβώς συμπεριφορά και υπάγονται στην κλάση Cash_desk.


**Αρχικοποίηση Τράπεζας** 
Η τράπεζα όταν ανοίγει πρέπει να αρχικοποιηθούν σε ορισμένη τιμή οι εξής μεταβλητές, μέσω της συνάρτησης bank.initialize() :Η last_customer=1, το curr_serving=1, το counter_open=0,η waiting_people=0 και τέλος με την open(0) ανοίγω το πρώτο ταμείο.Οι αρχικοποιήσεις αυτές γίνονται, γιατί από τα δεδομένα της άσκησης γνωρίζουμε ότι όταν η τράπεζα ανοίξει (προσοχή δεν εννοώ όταν θα κατασκευαστεί η τράπεζα), 'το χαρτάκι' που θα τυπωθεί δηλαδή αυτό το αναπαραστεί ο μετρητής last_customer, πρέπει να γράφει 1, ακόμη ο μετρητής counter_open (αποθηκεύει τον τρέχοντα αριθμό ανοικτών ταμείων), στην αρχή είναι 0 και θα αυξηθεί εσωτερικά της open, η οποία και αυτή θα κληθεί με όρισμα 0 (0 -> αριθμός προσδιοριστής του 1ου ταμείου).Τέλος η waiting_people μεταβλητή που χρησιμοποιείται σαν μετρητής, αναπαραστεί το πλήθος των ανθρώπων που δεν κατάφεραν να εισέλθουν στην τράπεζα.Στην αρχή δεν υπάρχει κάποιος πελάτης γι' αυτό τον θέτω ίσο με το 0.


**Εισαγωγή Πελατών**
Η εισαγωγή των πελατων επιτυγχάνεται μέσω της συνάρτησης bank.enter().Ξεκινόντας την εκτέλεση της enter() ελέγχω αν τα ανοικτά ταμεία επαρκούν μέσω της
συνάρτησης check_to_open.Αν αυτή επιστρέψει 0 τότε σημαίνει ότι τα τρέχοντα ανοικτά ταμεία επαρκούν και αυξάνει τον μετρητή εισαγωγής πελατών (δηλ. τον μετρητή last_customer).Αλλιώς αν η τιμή επιστροφής είναι το 1, τότε ελέγχει ένα-ένα τα ταμεία ποιό δεν είναι ανοικτό (ελέγχοντας την τιμή επιστροφής flag της συνάρτησης is_open).Το πρώτο κλειστό ταμείο που βρίσκει το ανοίγει, η υλοποίηση του ανοίγματος γίνεται μέσω της συνάρτησης open και αυξάνει το μετρητή last_customer.Αν υπάρχει η περίπτωση που όλα τα ταμεία είναι ανοιχτά,τότε ο πελάτης δεν είναι εφικτό να εισέλθει στην τράπεζα και γι αυτό τον "αποθηκεύουμε" στον μετρητή waiting_people ώστε να εξυπηρετηθεί σε 2ο χρόνο.


**Εξυπηρέτηση**
Η εξυπηρέτηση των πελατων επιτυγχάνεται μέσω της συνάρτησης bank.serve().Αρχικά η serve ενημερώνεται για το πλήθος των πελατών που περιμένει να εξυπηρετηθεί
(δηλ. τους πελάτες που κατάφεραν να εισέλθουν στην τράπεζα) μέσω της συνάρτησης wainting_customers().Έπειτα εξυπηρετεί έναν-έναν τους πελάτες.Για να γίνει η
εξυπηρέτηση ελέγχει αν τα ταμεία είναι (όλα) κλειστά, μέσω της opened_cashiers().Αν η τιμή επιστροφής είναι μηδεν (δηλ. 0 ταμεία ανοιχτά) γίνεται το άνοιγμα
του πρώτου ταμείου και αρχικοποιώ την μεταβλητή 'δείκτη' i_th ( i_th -> το επόμενο ανοικτό ταμείο που εξηπηρέτησε την προηγούμενη φορά) ίσο με 0 δηλ το 1ο ταμείο.Αλλιώς αν υπάρχουν ανοιχτά ταμεία ελέγχω ποιό είναι το επόμενο ανοικτό (μέσω της is_open) και ελεύθερο (μέσω της is_free).Στην συνέχεια επιλέγω το ταμείο που βρήκα (i_th=με το τρέχον ταμείο που επέλεξα) θέτοντας το σε κατάσταση serve (serving_flag=1) (δηλ το δεσμεύω), και μη ελεύθερο((free_flag=0) αυτό επιτυγχάνεται μέσω της συνάρτησης set_data.Όταν τελειώσω την εξυπηρέτηση ελευθερώνω το ταμείο μέσω της free ,η οποία θέτει τον σημαφόρο ίσο με ένα  (free_flag=1-->> ελεύθερο) και αυξάνοντας τον ατομικό μετρητή customers_served (μετράει το πλήθος των πελατων που εξυπηρέτησε το τρέχον ταμείο χωρίς να διακόψει δηλ. να κλείσει) και θέτει τον 2ο σημαφόρο serving_flag=0 (δηλ. δεν εξυπηρετεί).Όμως πριν τελειώσει η free ελέγχει αν το ταμείο υπολειτουργεί , δηλαδή αν ο μετρητής customers_served ισούται με το L.Αυτό δηλώνει ότι το ταμείο έφτασε στο μέγιστο πλήθος εξυπηρετήσεων που μπορεί να αντέξει.Έτσι αν η free γυρίσει τιμή 1 κλείνει το τρέχον ταμείο μέσω της close.Αλλιώς στην περίπτωση που η τιμή επιστροφής είναι 0 το ταμείο  συνεχίζει να λειτουργεί.Στο τέλος η serve κάνει έξοδο του πελάτη που εξυπηρετήθηκε μέσω της exit.Στην exit αυξάνεται ο μετρητής curr_serving (ο οποίος ενημερώνει ποιός αριθμός πελάτη θα εξυπηρετηθεί).Έπειτα ελέγχει μέσω της check_to_close αν πρέπει να κλείσουμε ταμείο.Αν η τιμή επιστροφής της check_to_close είναι 1 σημαίνει ότι κλείνει το πρώτο ανοικτό ταμείο (εξετάζοντας πάλι αν είναι ανοικτό με την is_open το τρέχον ταμείο που ελέγχει μέσω ενός βρόχου), όταν βρεθεί το πρώτο ανοικτό ταμείο σταματάει ο έλεγχος για τα υπόλοιπα και το κλείνουμε μέσω της close.


**Εξυπηρέτηση πελατών που δεν εισήλθαν κατά την πρώτη φάση στη τράπεζα**
Η εξυπηρέτηση των πελατών που δεν κατάφεραν να εισέλθουν στην τράπεζα με την πρώτη φορά επιτυγχάνεται μέσω της bank.service_wainting_customers(), η οποία εκτελείται μέχρι να μην υπάρχει κανένας πελάτης που δεν έχει εξυπηρετηθεί (μπορεί να κληθεί πάνω από μια φορά,γιατί σκοπός της είναι να μηδενίσει το πλήθος των πελατών που περιμένουν).Στην  αρχή της εκτέλεσης της συνάρτησης η service_wainting_customers θέτει σε μία νέα μεταβλητή το πλήθος των πελατών που δεν κατάφεραν να εισέλθουν που είναι αποθηκευμένο στον μετρητή  waiting_people τον οποίο τον μηδενίζει, έτσι ώστε αν κάποιος δεν μπορεί να εισέλθει για άλλη μία φορά να αποθηκευτεί εκ νέου στον μετρητή και να προσπαθήσει να μπει στην τράπεζα στην νέα κλήση της service_wainting_customers.Με έναν βρόχο πάλι καλείται η enter και έπειτα η serve.

Στο τέλος καλούνται αυτόματα οι destructors για την καταστροφή των αντικειμένων.

